.H 1 Verification/Validation
Two programs were written to verify that the ClassC/Elaine system
works as specified.  The first program represents a chess board with
its various pieces and generates legal moves for the pieces specified.
The second program simulates a multi-layer neural
network with a back-propagation learning algorithm.  This program was
written as a class project for a course on Neural Networks taught at the
University of Massachusetts at Amherst.

The first program ( Chess move generator ) was also written in C++ and Little
Smalltalk for a comparison.  As expected, the C++ program executed much
faster, about twice as fast.  The Little Smalltalk version, however, was
more than an order of magnitude slower.  This is presumably due to the
fact that Little Smalltalk is an interpreted language.

Between the two
programs, all specified feature of ClassC were tested and performed as
expected.  Some of the features tested were:
.AL
.LI
Redefinition of member functions in derived classes.
.LI
Multiple Inheritance.
.LI
Statement/Declaration mixing.
.LI
Structure and Array components of objects.
.LI
Multiple levels of object dereference (i.e., obj1:>obj2:>obj3:> ... )
.LI
Garbage Collection

.LE

The ClassC
source code of these test programs is provided as an appendix.
.bp
.H 1 Conclusions

.H 2 Problems
The two major problems I encountered were the multiple inheritance mechanism
and garbage collection.  Both are simple concepts but proved difficult
to implement in practice.

The dereferencing mechanism also required some thought.

Everything else was time consuming but straightforward.

.H 2 "Discrepancies of the System"
None observed.

.H 2 "Alternative Approaches for an Improved System"
I would have done nothing differently; but would have liked to have
done a good deal more --
.H 2 "Future Extensions"
I am aware of five areas in which ClassC can be improved:
.H 3 "Compiler Efficiency"
The compiler could be made faster and more efficient with memory resources.
I made very little effort to optimize the compiler itself.  It still manages
to process the ClassC code into C
in about half the time it takes the C compiler to
process the result.
.H 3 "Error Handling/Debugging"
Little was done to address the problem of bad ClassC programs.  The compiler
will report file and line number for syntax errors, but little more.
Some effort was made to include the ClassC source file and line number
information in the C code generated by the ClassC compiler for use by the
Unix SDB debugger.  This proved to be too time consuming and error prone
and so was abandoned.
I chose to spend the time enhancing the features of the language itself, as
that seemed the more interesting task.
.H 3 "Efficiency of Code"
I believe that the C code generated by the ClassC compiler is as efficient as
is possible for the algorithms I have used.
A more efficient implementation of ClassC may be possible.  If
so, however, this implementation would be very different
from the current approach.  I have no suggestions in this regard.

However, I believe there may be some opportunity for improved efficiency in the
runtime ClassC library routines.  A horrendous proportion of the running time of
a ClassC program is spent in the one function "_deref()"; as much as 40%.
I have tried to optimize its performance as much as is possible with simple
measures.  Any significant performance improvement would, I believe, require
a new algorithm for the "_deref()" function.  In particular, "_deref()"
currently performs a simple linear search on an un-ordered array of strings.
It would be straightforward to re-order the construction of the arrays
to allow a binary search or hash table look-up, etc.  Again, with limited
time I chose to focus more on the features of the language than its
efficiency.

.H 3 "Improved Garbage Collection"
The garbage collection mechanism in ClassC is primitive.  The simple
Unix memory allocation functions "malloc()" and "free()" are used for all
memory management.  No attempt at compaction is made.  Many improvements
could be made here.

.H 3 "Enhanced Language Features"
There is a great deal more that could go into ClassC.  In particular,
one feature I would like to add is overloading:

.AL
.LI
Overloading of Functions --
.br
Function overloading means the ability to define and use several different
functions that are called by the same name but take arguments of different
types.  Which of the several defined functions is actually called depends on
the type of the arguments used in the function call.

This is very simple to implement in practice.  The preprocessor/compiler
need only keep track of variable/expression types throughout the course of
the compilation.  When an overloaded function is called, the compiler can
just append the argument types to the function name to get a unique function
call.  For example, the function name "sqrt()" can be overloaded to accept
arguments of type "int" and "double" thus --
.br

sqrt ( 16 )    ==>   sqrt_I ( 16 )

sqrt ( 17.2 )  ==>   sqrt_D ( 17.2 )

This is easy for simple types, but unfortunately difficult for class/object
types.  The problem arises from inheritance, because an overloaded function
for a given class should apply to all classes derived from that class as
well.  The problem is compounded in a multiple inheritance environment.
If a class has three parent classes and each parent class has a form of the
overloaded function defined for it, how is the conflict resolved?

This is not an insurmountable problem; it can be addressed by simply
establishing a certain precedence and protocol -- such as, the first
ancestor class that appears in the class declaration list has first
precedence, and so on.  This requires further consideration, however, and
could be the basis for some future work.
.LI
Overloading of Operators --
.br
The same principle as function overloading, above, except using
standard C operators instead of function calls.
.bp
.H 1 "Bibliography"

.AL
.LI
Aho,A.; Sethi,R.; Ullman,J. [1986]
.I "Compilers - Principles, Techniques, and Tools"
Reading, MA: Addison-Wesley
.LI
Budd, Timothy [1987],
.I "A Little Smalltalk",
Reading, MA: Addison-Wesley
.LI
Cox, Brad [1986],
.I "Object Oriented Programming - An Evolutionary Approach"
Reading, MA: Addison-Wesley
.LI
Dahl, Ole-Johan [1966]
.I "Simula - An Introduction and Users Manual"
Oslo, Norway:  Norwegian Computing Center
.LI
Goldberg,Adele; Robson, David [1983]
.I "Smalltalk-80: The Language and its Implementation"
Reading, MA: Addison-Wesley
.LI
Harbison, Samuel & Steele, Guy [1984],
.I "C: A Reference Manual"
Englewood Cliffs, NJ: Prentice Hall, Inc.
.LI
Pratt, Terrence [1984]
.I "Programming Languages - Design and Implementation"
Englewood Cliffs, NJ: Prentice Hall, Inc.
.LI
Stroustrup, Bjarne [1986],
.I "The C++ Programming Language,"
Reading, MA: Addison-Wesley
.bp
