\section{Implementation}
The ClassC/Elaine compiler was implemented in a Unix System V environment
with the Yacc and Lex Unix language development tools.  The input files are
first processed by the C preprocessor
{\em cpp}.
This combines all the \#include .h files, substitutes all the \#define's,
strips the comments, and inserts appropriate source file/line number
information for error reporting.  The output is directed to a /tmp file which is
then parsed by the ClassC compiler, which creates a converted .c output
file.  Finally, the standard C compiler is invoked on the generated .c file
to produce the executable code or intermediate .o files for separate
compilation.

The first task was
to build a C language parser to make sure that the language would be a
proper superset of C  (the new C type
{\em enum}
was not included).  The the parser was then modified incrementally to add
the features of ClassC.  The ClassC/Elaine system was implemented as
follows:

\subsection{Statement/Declaration Mixing}
In ClassC, statements and declarations can be mixed together within a single
block, as long as variables are declared before being used.  In standard C
all declarations are required at the start of a block before any executable
statements.  In order to convert the ClassC blocks into C format, the code
within each block is separated into two collections --- a statement list and
a declaration list.  This is a recursive procedure, because blocks can be
nested and blocks within blocks are themselves statements.  So a global
variable ``block\_number'' is maintained and the block code is partitioned into
the appropriately nested collection of block statements and declarations.  At
the end of a block, the statements and declarations are re-merged, with all
the declarations floated to the top of the block.  The order of the
declarations is maintained so that references to previous declarations
within the same block are valid.
\subsection{Inline Comments}
All text between ``//'' and the newline character is an inline comment and
is removed from the input file by the lexical analyzer generated by lex.
\subsection{Class Definition}
A class definition is written in the form:
\begin{verbatim}

class  Class_name  : SuperClass_1  : SuperClass_2 : ...
	{	<type> <declarator>;
	 	<type> <declarator>;
	 	<type> <declarator>;
	 	<type> <declarator>;
			.
			.
			.
	};


\end{verbatim}

\noindent
where SuperClasses are optional ancestor classes and declarators may be any
legal ClassC declaration; particularly, they may be function declarations or
object declarations (not definitions).
The parser is a two pass parser.  The first pass just builds a list of class
names from the class definitions in the file.  No kind of error checking is
done at this stage.  The second pass is the true parse, but all the classes
defined in the file are now known to the compiler.  Thus, a class which is
defined anywhere in the file can be used anywhere in the file.  This allows
forward referencing inside class definitions, so that class A can be
defined to contain objects of class B while class B can likewise
be defined to contain objects of class A.

When the second pass of the parser encounters a class definition, it
first processes all the declarations within the body of the definition.
The variable declarations are treated just like structure component
declarations and are entered into a symbol table which is maintained for
each class definition.  The function declarations are put into a separate
function symbol table for the class entry.  So each class entry has two
symbol tables in it --- one for the member functions, and one for member
variables.

After building the two symbol tables from the class definition section, the
parser examines the parent classes of the class being defined.  If the
parent classes contain new symbols, these symbols are added to the
appropriate symbol tables.  If a parent class contains a symbol that
is already in one of the symbol tables and they are
declared to be the same type,
the duplicate declaration is skipped and the next symbol is processed.  If
a parent class contains a symbol of the same name as one already in a symbol
table but of a {\em different} declared type, an error has occurred and is reported by the parser.

After all the parent classes have been examined and all the symbol tables
built, the ClassC compiler creates two pieces of C code.  The first
piece of code is a structure definition with the same name as the class,
except with a prepended underscore.  That is, a class called ``Garuda'' would
have an associated structure definition ``\_Garuda''.  This structure definition
contains all the variable symbol components of the class, both those
explicitly declared in the definition section of that class as well as those
symbol names inherited from super classes.

The second section of C code produced by the compiler for every class
definition is a set of function declarations corresponding to the function
components of the class.  The declared function names in this section
consist of an initial underscore followed by the class name, underscore,
and function name.  Only those functions explicitly declared in the
class definition section are represented here --- the functions which are
inherited from ancestor classes are declared with the ancestor classes.
For example, the declared Garuda component ``double burn();'' would be
translated into the C declaration ``double \_Garuda\_burn();''.

It would be possible to put pointers to member functions directly in
the objects structures.  These pointers would be difficult to
initialize, however, and would add an extra level of indirection to
a member function call.  There was no obvious compensating benefit
for implementing member functions in this way, and so it was not done.


{\noindent \large \em Tables ---}

Several tables are maintained by the ClassC compiler while parsing
a source file.  The class table is a list of all the declared classes with
associated information about their ancestors and components.
A similar table is maintained for structures, and symbol tables
contain information about variables and functions.
The class table is described in detail below.

Each class table entry contains two symbol tables (variable and function)
containing information about the data members and function members of
that class.
Each of these component symbol tables is in turn composed of a linked
list of structures, where each
structure is a single symbol table entry.

Both function and variable symbol tables use the same structure format
for each entry.
The symbol table entry structure has the following form:

\begin{verbatim}

struct sym_entry {
		   struct sym_entry *next;
		   char * name;
		   char * spare;
		   char * typestr;
		   int 	  blk_no;
		   char * declaration;
		   char * abstract_dec;
		 };

\end{verbatim}
\vspace{3ex}
\begin{description}
\item[struct sym\_entry * next; ---]
A pointer to the next entry in the symbol table.
\item[char * name; ---]
The declared name of the symbol.
\item[char * spare; ---]
This is used in the function symbol table of class entries.  It contains the
real name of the function.  The real name of a class function is constructed
by concatenating the class name in which the function was defined with the
declared name of the function itself.  Thus for class Student, the member
function ``printName();'' would appear as ``printName'' in the ``name'' field
above, and as ``\_Student\_printName'' in the ``spare'' field here if that
function is declared in the Student class declaration.  If, however, the
function ``printName'' is not declared in the ``Student'' class definition but
is rather inherited from a super class such as ``Citizen'', the string
appearing in the name field would still be ``printName'', but the string in
the spare field would be the name under which the function is defined;
that is, ``\_Citizen\_printName''.
\item[char * typestr; ---]
The component {\em typestr} represents the type of the declared variable.  This
includes not only the basic type of the variable, but also its indirection.
The type is represented by a single letter code for the basic type,
preceded by character codes indicating the dereferencing necessary to
produce the basic type.  That is, if the variable VAR is declared as
\begin{quote} \tt int (*VAR[5])(); \end{quote}
the type string for VAR would be
\begin{quote} ppfi \end{quote}
which is interpreted as array (same as pointer) (p) of pointers (p)
to functions (f) returning integer (i).

The basic types are (i) for
{\em long'}s {\em short'}s {\em int'}s {\em unsigned'}s and {\em char'}s.
The character (d) is used for {\em double'}s and {\em float'}s; and so on.
The only types that require more than a single character code
are aggregate types --
{\em struct'}s, {\em union'}s, and {\em class'}s.  These are represented
by the character (s) or (u) or (k) followed by the structure,
union or class name.  Thus, for the declaration
\begin{quote} \tt struct Sym\_entry * table; \end{quote}
the variable {\em table} has associated with it the type string
\begin{quote} psSym\_entry, \end{quote}
which is interpreted as pointer (p) to structure (s) Sym\_entry.
\item[int blk\_no; ---]
Block number --- this is not used in the class entry tables, but
the same structure format is used for all symbol tables used by the parser.
The block number is used by the parser with the variable declarations
in the file itself to maintain scoping information.
\item[char * declaration; ---]
The character string {\em declaration}
keeps an copy of the declaration string used to declare the component variable.
This is used later if any additional classes are derived from the class
currently defined.  If so, this declaration string is reproduced in the
derived class.
\item[char * abstract\_dec; ---]
The abstract declaration equivalent to the variable declaration with the
variable name removed.  It is used for casting values returned by the class
dereferencing function {\em \_deref()} (or by the inline dereferencing option
explained below), to the appropriate type.
\end{description}

The class table itself is made up of a linked list of class entries, where each
entry for a class has the form:
\begin{verbatim}

struct class_entry
	    {
		struct class_entry *next;
		char * name;
		struct sym_entry * sym_table;
		struct sym_entry * fnc_tbl;
		char   * ancList; /* Ancestor list */
		char * initQ;	/* Is there a user defined
				 * init() function for this class?
				 * If so, what is it? */
	    } ;



\end{verbatim}
\begin{description}

\item[ struct class\_entry * next; ---]

Pointer to the next entry in the class table.
\item[ char * name; ---]

The class name.
\item[struct sym\_entry * sym\_table; ---]

The component variable symbol table for the class.
\item[struct sym\_entry * fnc\_tbl; ---]

The component function symbol table for the class.
\item[char   * ancList; ---]

The list of superclasses for the class.  This list includes not just the
super classes declared in the super class declaration line of the class
definition, but all the super classes of those super classes as well --- that
is, the entire class membership hierarchy for that class.
\item[char * initQ; ---]

Does this class have a declared {\em init()} function?  This is used by the
compiler when it encounters a {\em ClassName:$>$new()} expression for a class.
The first thing the {\em ClassName:$>$new()} expression does is
allocate space for
the structure defined for {\em ClassName}.  Then, if the user has declared an
initialization function for that class, it is called with the appropriate
arguments.  If no such function has been declared for that class, the
structure is allocated with uninitialized memory.
\end{description}
\subsection{Inheritance Mechanism}
The heart of the ClassC/Elaine system are the inheritance/dereferencing
mechanisms.  This
is the most difficult factor in implementing a multiple inheritance object
oriented language on top of C.

In C++, ObjectiveC, and ClassC, objects are implemented through C structures
and associated functions.  This works well for single inheritance systems,
because the class components can be laid down in a conventional
manner to take advantage of the standard C mechanism for structure
dereference.

For example, consider how a linear (single parent line) inheritance system
might be implemented.  A class declared without any super classes would be
represented by a structure containing the member variables of that class
along with a set of functions associated with that structure name.

A class derived from this parent class might have additional variable
components.  The structure representing the derived class would be identical
to that of the parent class except for the additional fields added at the
end.  This means that all the dereferencing mechanisms that can be applied
to the parent class can be applied to the derived class as well because the
two classes have the identical structure components in the identical
locations for all components found in the parent class.  This allows all
functions defined for the parent class to be applied to the derived class,
which is essential for the concept of class inheritance.

Now consider the case of a multiple inheritance system.  The above principle
can still apply to the first ancestor of a derived class.  What about the
second?  There are two possibilities.


{\em Orthogonal super classes ---\\}
If none of the components of the super classes have any element names in
common, there is no real conceptual problem; only tricky pointer
manipulation by the compiler.  Instead of having identical component layout
as its ancestors, the components of the derived class differ from its
ancestor classes by a constant offset (which is zero for the first ancestor
class and progressively larger for each successive super class).  When a
derived class is manipulated by functions derived from ancestor classes,
the relevant offset can be added to a pointer to the derived class object,
and again the derived object can be manipulated transparently by the super
class functions which have no knowledge of the other components of the
object.

This solution is good in that it implements a form of multiple inheritance
while still allows use of the standard C
structure dereferencing operations.  It is fast and very simple to
implement.

This solution is bad in that is suffers from a lack of generality.  The
super classes must be orthogonal, which is not always a reasonable
requirement.  Imagine two classes used in a university database system -
\begin{quote} \tt Class Student; \end{quote}
and
\begin{quote}\tt Class Employee. \end{quote}

Imagine we wish to create a new class derived from both ---
\begin{quote} \tt Class GradAsst : Employee : Student \end{quote}

Well, from Class Employee, Class GradAsst can inherit {\em double Salary;}
and {\em int EmployeeNumber;}.  From Class Student, Class GradAsst can
inherit {\em double GPA;} and {\em int StudentID;}.

What about {\em char * name;}?  This field is found in both Class Employee and
Class Student.  The Employee functions will manipulate the employee
name component; the Student functions will manipulate the student name
field, and which parent provides
the name field for GradAsst functions is undefined.

One possible solution is to go back and modify all the existing source code
for Employee and Student to change all references to name to Employee\_name
and Student\_name.  Then GradAsst could add a new component {\em char *
GradAsst\_name;}.  This solves the ambiguity, but it is now impossible
to use functions derived from either Employee or Student to manipulate the
new entry {\em GradAsst\_name}; and the class GradAsst now has two
empty fields it will never use; Employee\_name and Student\_name.  Or
GradAsst could just use one of the super class name fields; say
Student\_name.  This reduces some waste but does not give us proper
abstraction or symmetry.

Worse, consider the problem of incest.  That is, imagine the super class
UniversityPersonnel.  This class could contain all information common to
everyone associated with the university --- that is, name, birthdate,
address, etc.  From class UniversityPersonnel are derived the subclasses
{\em Faculty}, {\em Student}, {\em Staff}, {\em Employee}, etc.
Then from {\em Student} and
{\em Employee} we derive {\em GradAsst} as above.  This is an unmanageable
situation, which is solved by simply avoiding it.  No such inheritance
structure is useful under the multiple inheritance mechanism described
above.  This is unfortunate, because it is plain that much functionality
must now be duplicated in each of the derived classes that could have been
handled in the single super class {\em UniversityPersonnel}.

This problem only exists when an attempt is made to achieve multiple
inheritance with the standard C structure dereferencing mechanism.  This is
because at compile time the C compiler converts structure dereference
symbols to integer offsets into the structure itself.
Therefore the positions of the structure components must be fixed at
compile time, which is impossible in a general multiple inheritance
scheme.
If it were possible to use a different dereferencing mechanism to dereference
the structure at
{\em runtime}, the above difficulties in multiple inheritance
could be cleanly resolved. The object component would be dereferenced
by the symbol itself and not by a precalculated offset.
Such a mechanism is used in ClassC.  The cost of
this mechanism is greatly increased operating complexity and a significant
decrease in dereferencing efficiency.  This is the mechanism used in
ClassC, as described below.

Runtime Symbolic Dereferencing ---\\
After the compiler parses the class definition, it creates a static array of
structures {\em \_ref\_el}.  The structure {\em \_ref\_el} is a character
pointer/integer pair defined as:

\begin{verbatim}

struct _ref_el	{ char * name;
		  int offset;
		};


\end{verbatim}
This data structure is used to match the class component names with
their relative position in the class structure.
Each class has one such array created for it immediately after the class
definition.  The array is divided into two sections --- the first section
represents the variable components of the class; the second section
represents the function components.  Each component of the variable
section of the array pairs a name of class component with its offset in the
structure.  The offset is found by casting zero to be a pointer to a
structure of the type built for the class, then dereferencing the component
for that class, taking  its address, and casting the result to an integer.

This is perhaps more clearly illustrated by example:

If the class Munn is declared to have the data component {\em float eye;}
the array of struct \_ref\_el's for Munn is defined as:
\begin{verbatim}

struct _ref_el  _Munn_ref [] =
		{ { "eye", (int) (& ( (struct _Munn *) 0)->eye) },
		  { ...
		  { ...
		};



\end{verbatim}
where struct \_Munn is the structure created by the parser to represent the
variable portion of the class Munn.

This section is terminated by a null character pointer in the name position
and the second section depicts the absolute address of the real function
corresponding to the class member function.  This section is also terminated
by a null pointer in the name field.

So for each declared class an array of paired names and offsets is created.
This array and the component name is then used by the ClassC runtime
function {\em \_deref()} to return the component selected.

The runtime operation is described later; the following example may clarify
the above discussion ---

{\noindent \large \em Example:\\}
Consider as above class GradAsst as a subclass of both classes Employee
and Student.  The function printName might be defined for both super
classes.
\begin{verbatim}

class GradAsst : Student : Employee
	{ int contract_no;
	  printSchedule();
	};

\end{verbatim}
\vspace{3ex}

Assume that regular employees do not work under grant contracts
and hence have no contract number, so the field {\em contract\_no} is unique to
class GradAsst.  Let us also assume that BOTH class Employee and
Student have a member function {\em printSchedule}, but that the format we
want for GradAsst is a little different from each, so we intend to
redefine it for GradAsst.

The first thing the parser does is make a class entry for the new class
GradAsst.  It also starts to build two symbol tables for class
GradAsst --- one for the variables and one for the functions.
The declarations in the body of the GradAsst are processed first and
entered into the two symbol tables.  Then each symbol entry for Student
is scanned by the parser, and compared to the entries already in the class
entry for GradAsst.  If not already present, a new entry is made in the
GradAsst symbol table and the Student symbol entry is copied into
it.  So GradAsst gets the field {\em int employeeNumber;} from
Employee, and {\em void printName();} from Student.  But since the member
function {\em printSchedule} is included in the definition of GradAsst,
the parser ignores the declaration of that function in Student and Employee
(except to make sure the type is declared consistently).

After processing the declaration section of the GradAsst definition and
building the symbol tables from the superclasses, the ClassC compiler
outputs a structure definition for struct {\em \_GradAsst} ---

\begin{verbatim}

struct _GradAsst
	{ char * name;
	  int contract_no;
	  int studentID;
	  int employeeNumber;
	  struct Schedule schedule;
          .
          .
          .
	};



\end{verbatim}

After the structure declaration come the member function declarations:
\begin{verbatim}
int \_GradAsst\_printSchedule();


\end{verbatim}
In this case, since only one member function was declared within the body
of the class GradAsst definition, only one function is declared here.
Recall that the other inherited functions are
declared elsewhere and need not be redeclared here.
{\em printName();}, for example, is inherited from class Student, where it
is declared {\em int \_Student\_printName();}.  In class GradAsst, the
function table contains the entry {\em printName} which is matched with the
full name {\em \_Student\_printName} in the field labeled {\em spare}.

After the function declaration section comes the array of
{\em struct \_ref\_el}:


\begin{verbatim}


struct _ref_el _GradAsst_ref [] =
    { { "name"	, (int) (& ( (struct _GradAsst *) 0)->name) },
      { "contract_no", (int) (&((struct _GradAsst *) 0)->contract_no)},
        .
        .
        .
      { 0,0 }, /* This marks the end of the variable component section*/
      { "printName", (int) _Student_printName },
      { "printSchedule", (int) _GradAsst_printSchedule },
        .
        .
        .
      { 0,0 }, /* This marks the end of the array */
    } };



\end{verbatim}

These declarations depend on three features of the
C compiler.

1) Variables of arbitrary length are legal
and significant.

2) Function names not followed by paired parenthesis
are equivalent to a function pointer and return the
{\em address} of the function.

3) Pointers can be represented in unsigned integers.

\subsection{Object Table}
An object variable in ClassC is implemented as an index into a
dynamically constructed object table.  Each table entry
has three components ---
\begin{itemize}
\item {\bf The reference count:}\\
To implement garbage collection, each object table entry has a
reference count associated with it.  When the garbage collection option is
selected by the ClassC command line argument
{\em -G}, the ClassC runtime functions \_incRef and \_decRef are invoked
with each object assignment to keep track of the reference counts.
\item {\bf The Variable Structure Pointer:\\}
All objects of the same class share the identical class functions, but each
object has its own private data.  As indicated above, this private copy of
object data is manipulated in the form of a C structure.  When an object is
created, a space the size of its data structure is allocated by malloc, and
a pointer to that structure is entered into the object table for that
object.  Since each class has a different structure type, the structure
pointer is cast and stored in the object table as an integer.
\item {\bf The Class Reference Array:}%\\
When an object is created by invoking {\em ClassName}:$>${\tt new()}, an
entry is made in the object table and a pointer to the reference array
created for {\em ClassName} is inserted.  When the dereferencing function
is given an object/index and a selector token (string), it uses the
dereferencing array in the object table to find the appropriate
offset/address for the token.
\end{itemize}
\subsection {Objects}
Objects in ClassC are allocated dynamically from the heap at run time
by a call to {\em new()}, which in turn calls the unix function {\em malloc()}
to allocate memory.
What the user really sees and manipulates is the 
{\em object variable.} Object variables are implemented as
{\em int'}s in C.  An object variable is actually an index into the object
table described above.  When
a value is assigned to an object variable, it represents an index into the
object table which contains a pointer to the real object data in memory.
Thus, when one object variable is assigned to another, the object
data is not copied; just a reference to that object data.  The user must
define explicit functions to actually copy the data from one object to
another.

\subsection{Object Variables When Using Garbage Collection}

When the garbage collection option is selected,
objects are implemented as
{\em static} or {\em extern} {\em int'}s in C.  The reason for this is
reference counting.

Whenever two object expressions appear on each side of an
assignment statement, the reference count of the right hand object is
incremented and the reference count of the left hand object is
decremented BEFORE the assignment is made.

If object variables were created automatically on
entry to a function and released again on exit, object references would
keep disappearing without the appropriate reference count decrements.
\vspace {2ex}

Consider the following example:
\begin{verbatim}

Samp( arg ) object arg;
{ object localObj;
  localObj = arg;
}
\end{verbatim}



With the garbage collection option, this ClassC code is translated to:

\begin{verbatim}
Samp (arg) int arg;
{ static int localObj = 0;
  *_decRef( &localObj ) = _incRef( arg );
}


\end{verbatim}
If objects were automatic integer variables, the value of {\em localObj} is
undefined on entry and exit from {\em Samp()}.  Thus, {\em \_decRef()} would
be applied to an undefined integer; the object pointed to by {\em arg} would
get incremented each time the function was called and some indeterminate
entry in the object table would get decremented, or a bus error would occur
if {\em localObj} happened to take on a value out of the range of the table.
If {\em Samp(arg)} were called a thousand times, the object {\em arg} would
be incremented a thousand times and never decremented, while unknown and
random object entries would be decremented.  The problem of random
decrementing of reference counts could easily be handled by initializing the
automatic integer localobj to zero, but the object pointed to by {\em arg}
will still get its reference count incremented each time the function is
called, never decrementing the count on exit.

One possible solution to the problem of reference counts would
be to keep track of all objects
in the function definition and automatically dereference all of them
when quitting the function, but functions often have multiple
exit points, and it becomes complicated to insert all the reference
decrementing code at every possible exit point.
In addition, this would add a great deal of runtime overhead to
already costly function calls.

Therefore, an alternative solution to the problem of keeping track of
object reference counts was found.  This solution uses static integers to
represent object variables.  Static variables are not allocated and
deallocated from the stack.  Instead they have a continued existence
throughout the life of the program.  This means that the memory occupied
by an object variable is not reclaimed at exit from a function, but this
is not as costly as it may seem.  Recall that the object {\em variable} is
only an integer pointing to the true (possibly huge) object in dynamic
memory.  It is the object {\em variable} which is static in this scheme.
In the common case of four bytes per object variable, a program might have
several hundred thousand to several million static object variables before
the cost of the unreclaimed static integers became significant in a
typical application.

These static variables retain their value between calls to a function,
thus when the above assignment is performed ---
\begin{quote}\em *\_decRef( \&localObj ) = \_incRef( arg );\end{quote}
the object initially pointed to by localObj is the {\em previous}
object index which was used as an argument on a call to Samp() (or zero, the
null object pointer, if this is the first call to Samp()).  The reference
count of this previous object is now decremented, the reference count of
the new argument is incremented, and order is maintained.

All object variables are initialized to zero.  \_decRef and \_incRef
recognize the zero index as a special case and take no action when
given zero (for \_incRef) or a pointer to zero (\_decRef) as arguments.
Thus, initial assignments can be made to an object variable without
decrementing any object reference counts.

Again, this automatic allocation of object variables to static storage
classes is
only implemented when the -G option is selected at compile time.

\subsection {Runtime Library Functions}
The ClassC compiler generates function calls to create objects, dereference
objects, count references, etc.
\subsubsection{The creation functions new()}
{\em new()} creates a new object by allocating memory for the object from the
heap, making and initializing a new object
entry in the object table, and returning the index of that new entry.
There are two {\em new()} functions; {\em \_new()} (one underscore) and
{\em \_\_new()}
(two underscores).  The first is used in non-garbage collected environments,
the other when garbage collection is implemented.

{\flushleft \large \bf \_new() ---\\}
The non-garbage collection version is the simpler of the two.
The parser invokes {\em \_new()} when it sees an expression of the form:
\begin{quote} \em obj = ClassN :$>$ new(); \end{quote}

If class {\em ClassN} has no {\em init()} function specified, the parser
translates the create object expression to:
\begin{quote}
    \em obj = \_new ( sizeof (struct \_ClassN), \_ClassN\_ref ));
\end{quote}

{\em \_new()} first gets the next available index for the object table, and
grows the table if necessary.  It then allocates space for the data
portion of the object through a call to {\em calloc()}
and assigns the address of the newly allocated memory
space to the table entry field {\em self}.  The pointer to the array of
reference elements ( \_ClassN ) is assigned to the table entry field
{\em class}.  Finally, the new index is returned and assigned to
the object variable {\em obj}.

If the class ClassN
{\em does} have a member {\em init()} function declared, the translation
of the expression
\begin{quote} obj = ClassN :$>$ new ( argList); \end{quote}
is
\begin{quote} \tt
obj = \_ClassN\_init(\_new(sizeof(struct \_ClassN),\_ClassN\_ref),argList);
\end{quote}

The {\em \_new()} function is invoked in the same way as before,
but instead of returning
directly to the object {\em obj}, it returns as the first argument to the
ClassN {\em init()} function.  The init() function itself operates on the new
object with the arguments in the (possibly empty) argument list {\em argList}.
When the {\em \_ClassN\_init()} function is translated from ClassC to a C
function, the ce compiler automatically generates a {\em return} statement,
returning the index of the new object to {\em obj}.

This is why it is illegal for the user to include a {\em return} statement in
an {\em init()} definition.

{\noindent \flushleft \bf \_\_new()\\}
Only the action of {\em new()} is different when garbage collection is invoked.
Collection is an expensive procedure, and should be invoked infrequently.
To minimize unnecessary calls to collect, two global (external) variables,
CEGthreshold and CEGfrequency, are defined in the ClassC library.

Until the threshold table size is reached, calls to {\em \_\_new()} execute like
calls to the non-garbage collection version.  A new table entry is
allocated and a new object is created.

After the table size threshold is reached, each call to {\em \_\_new()}
increments a counter.  When the counter reaches a multiple of the
integer CEGfrequency, the collection routine is invoked.

Both the table space used by an object as well as its actual storage memory
are released by the {\em collect()} routine.  The dynamic storage occupied by
the object itself is released by the standard Unix {\em free()} function.
The table entries (indices) occupied by the collected objects are pushed
onto a free entry stack.

After the collection, \_\_new() looks at
the stack of freed object table indices, pops it, and uses the recycled index
for the newly created object.

/subsubsection{Garbage collection function 'collect();'}
{\em collect()} is implemented very simply.  It starts at the beginning of the
object table and examines the reference count field of each entry.  If
the count is zero (0), {\em collect()} calls the function {\em \_delete()}
on the
object, frees the memory allocated to the object, and pushes the object
table index number for that object onto the free entry stack, which is
popped by {\em \_\_new()} as described above.

\subsubsection{The deletion function '\_delete()'}
{\em \_delete()} is called automatically by {\em collect()}, or may be called
explicitly by the user.
The delete function checks to see if there is a user defined
cleanup function {\em delete()} declared for the class/object being deleted.
If so, that cleanup function is called before the object itself is deleted.

For example, an object may contain a character pointer.  During the course
of the object's lifetime, it may have dynamically allocated a large chunk
of memory to which the character pointer now points.  Freeing the storage
allocated to the object will free the pointer, but not the memory pointed
to by the pointer.  The user must explicitly define a member {\em delete()}
function for that class that frees the memory pointed to.  It is this
delete() function that is called by \_delete() if it exists.

Whenever {\em collect()} calls {\em \_delete( obj )}, the reference count for
object {\em obj} is zero.  This is not necessarily the case if the user
explicitly deletes an object.  If many object variable reference the same
object, one delete should only delete one reference to to object, not
the object itself.  So the function {\em \_delete(obj)} first checks
the reference count for object {\em obj}.  If it is non - zero, the
object is not deleted; but the reference count is decremented.  This is
much like the behavior of the Unix {\em rm} file command.

\subsubsection{The reference count functions}
{\em \_incRef(obj)} and {\em \_decRef(\&obj)} increment and decrement
the reference count field in the object table for the object argument.

{\em \_incRef( obj )} simply uses {\em obj} as an index into the
object entry table, increments the associated reference count, and
returns the object.

{\em \_decRef( \& obj )} takes a pointer to an object as an argument,
dereferences
it, indexes into the object table, and decrements the appropriate reference
count.  It returns the object pointer (address).

These function calls are included only when using garbage collection.  The
expression:
\begin{quote} obj1 = obj2; \end{quote}
would be translated as:
\begin{quote}
* \_decRef (\&obj1) = \_incRef (obj2);
\end{quote}

{\em \_decRef()} takes and returns a pointer argument in order to change
the value of the variable {\em obj1}.  Furthermore, note that the precedence
of the parser is set so that cascaded assignments of objects work as
expected.  That is:
\begin{quote}
obj1 = obj2 = obj3;
\end{quote}
is translated as:
\begin{quote} \tt
*\_decRef(\&obj1)=\_incRef (*\_decRef (\&obj2)= \_incref (obj3));
\end{quote}

Object variables were used here to illustrate this example, but this
procedure is applied in general to {\em expressions} that evaluate to
class types, of which object variables are just an instance.

For instance, an example of a complex expression that evaluates to an object is
\begin{quote}
* someFunction() [6];
\end{quote}
where {\em someFunction()} is declared to be a function that returns a
pointer to an array of object pointers.

\subsubsection{The dereferencing function \_deref()}

The dereferencing operations are the heart of the ClassC system.  It is
this method that allows transparent dynamic binding and the implementation
of multiple inheritance.

1) What does \_deref do?\\
The function {\em \_deref()} takes two arguments.  The first argument is an
object variable.  The second argument is a string/character pointer which
is the name of the object component we want to access.

{\noindent \bf Example ---}
\begin{quote}
\_deref( objVar, {\em elementName});
\end{quote}
{\em \_deref()} returns a pointer which represents either the address of a data
component of the object, or the address of a function component of the
object.  Recall that all objects of the same class share the same function
implementation, but have their own copy of private data.  Therefore,
{\em \_deref()} must distinguish between function names and data names.

It is necessary to call \_deref instead of using a direct structure
dereference because of the way multiple inheritance has been implemented
in ClassC.  An object of a derived class can be assigned to an
object variable declared to be of a parent class type.  The positions
of the components of the derived type may be different from the components
of the parent type, and so a standard C structure dereference (which
depends on the order of the components being known at compile time)
cannot be used.

2) How is \_deref used?\\
The parser recognizes two types of object dereferences ---\\
a data component dereference that has the form:
\begin{quote}
objName:$>$ componentName;
\end{quote}
or a function component dereference of the form:
\begin{quote} objName :$>$ funcName ( optionalArgs ); \end{quote}

The compiler translates the data reference expression to a call to \_deref() ---
\begin{quote} \tt
\_deref(objName,"componentName");
\end{quote}

The value returned by {\em \_deref()} is an address.
If the compiler knows the class of the object, it looks up the class in the
class table to determine what return type to expect from the dereference.
It then casts the returned value of \_deref() to a pointer to an object of
that type, then dereferences the pointer with the pointer operator '*'
to generate the actual object itself.

So if {\em componentName} were a reference to an array of seven integers,
the full translation of the reference
\begin{quote}
objName :$>$ componentName
\end{quote}
would be
\begin{quote} \tt
* (int (*) [7]) \_deref(objName,"componentName")
\end{quote}

There are two reasons to have \_deref() return an address instead of the actual
component dereferenced.
\begin{itemize}
\item A function can only return one type.  If \_deref() were expected to return
the actual entity  (component) dereferenced, all components would have
to be of the same type.  A single dereference function could not
be used to return both a structure component and a floating point component.
By returning an integer that can be cast as a pointer to any type, we
can use a single \_deref() function to access any component type.
\item Returning a copy of the component itself would be adequate if we just
wanted to read it, but it does not help us if we want to set it.  With a
pointer implementation, both the following ClassC statements work
as expected.

a = obj :$>$ component;

obj:$>$ component = a;

If \_deref() returned the value of the actual component itself, the second
statement would have no effect; and would in fact translate to an illegal
C statement, because the return value of a function is not an l-value.

\end{itemize}

The same class dereference operator ``:$>$'' is used to dereference object
{\em functions.} In this case, \_deref() returns a pointer to a function;
that is, \_deref returns an integer which is immediately cast to a function
pointer.  In fact, it is cast to a pointer to a function returning the
type expected from the component function name.  For example, if the
component function {\em nameList()} is expected to return a pointer to an
array of character pointers, the reference
\begin{quote} \tt
obj:$>$nameList ( argList );
\end{quote}
will be translated to
\begin{quote} \tt
(( char * (*((*)()))[99]) \_deref (obj,"nameList")) (obj, argList)
\end{quote}

Thus, \_deref() returns an integer which is cast immediately to a pointer to
a function which returns a pointer to an array of pointers to char.  This
function pointer is then dereferenced by the function pointer dereference
operator {\em ( obj, argList )}.   Note the inclusion of the object name itself
in the translated call to the member function {\em nameList()}.  This is because
the function {\em nameList()} is meant to access only the private data of the
particular object dereferencing it ( in this case, the object {\em obj} ); not
the data of other objects in the same class.  This means that when called,
the function {\em nameList()} must be able to tell which object invoked it.
Hence the inclusion of the object variable {\em obj} in the argument list.
The interface is neater if this is done automatically so that the user is
free of this responsibility.

3) How is \_deref implemented?\\
The dereference function is called with two arguments ---
an object variable
( integer index into the object table ), and a string (character
pointer) representing the field (component) to be dereferenced.
The {\em \_deref(object,fieldName)} algorithm proceeds as follows:
\begin{enumerate}
\item {\em Get the array of \_ref\_el for the object class ---\\}
Recall that an object table entry has one field that contains a pointer to
an array of string / offset pairs.  Vector into the object
table with the object
index and get the pointer for that array.
\item {\em Do a while loop.\\}
Step through the array and examine the value of the
character pointer.
If the character pointer in the {\em name} field of the array is NULL (0), this
is the end of the data section of the array.  The second section of the
array has function names, which are dealt with differently by {\em \_deref()}.
Drop out of the while loop and continue to the next section of the {\em deref}
function (Step 3).

Otherwise, compare the name field in the array with
the string {\em nameField} passed as an argument to the {\em \_deref()}
function.
\begin{enumerate}
\item
If the strings are the same, get the integer offset that corresponds to
this name in the reference array.
Vector into the object table with the object
again and get the pointer to the beginning of the structure that holds
the object's data.  Return the sum of the offset and the structure
address.
\item
If the strings are different, increment the index and repeat the loop ---
go to the next element of the array and repeat the string comparison.
\end{enumerate}
\item
If we get this far, we know the fieldName was not found in the first section
of the array.  Therefore, it was not the name of a data element for that object.
Now do the same type of loop as above, checking to see if fieldName is found
in the function section of the array.  If found this time, however, produce
the value of the offset only.  This is a pointer to a function, and is
not to be added to the address of the object structure.  Return it.
\item
If we come to the end of the array (another null character pointer in the
name field), the component has not been found in the object, and a runtime
error is reported.
\end{enumerate}

\subsection{The Problem of Non-Idempotentcy}
The parser keeps track of the declared type of all identifiers.  But an
identifier is just a specific instance of the more general syntactic
structure {\em expression}.  This means that not only variables, but
also complicated expressions can
evaluate to an object type and then be dereferenced.
Thus it is possible to dereference arrays of objects and functions returning
objects.  For example, if {\tt myObj} is declared as an array of pointers
to object and {\tt next()} as function returning object, both:
\begin{quote}
*myObj[5]:$>$ myComponent;
\end{quote}
and
\begin{quote}
next():$>$ reset();
\end{quote}
are legal ClassC expressions.

This first expression is translated to
\begin{quote} \tt
\_deref ( *myObj[5], "myComponent");
\end{quote}

The second expression poses a problem.  Recall that class member functions
take the receiver object as the first argument to the function.  Thus,
the second expression above might be translated to:
\begin{quote} \tt
( (int (*) ()) \_deref( next(), "reset" )) ( next());
\end{quote}

Where the object returned by {\em next()} is dereferenced with the
selector {\em reset}, the value is immediately cast to a function pointer
(because {\em reset} is a member function), and the resulting function pointer
is called with the target object returned by {\em next()} as its only
argument.

It is tolerable to call {\em next()} twice if it always returns the same
value.  If {\em next()} is not an idempotent function, however, the program
will behave badly.

It is necessary to ensure that a function is evaluated only once in
such an expression.  This can be done by using a temporary variable.
Then the expression can be translated as:

\begin{quote} \tt
((int (*)())\_deref(tmpObjVar, "reset" )) (tmpObjVar = next());
\end{quote}

A problem exists to this solution.
There is some ambiguity in the order of evaluation in sequential
function expressions.  It was empirically discovered that most C
compilers evaluate the function arguments from right to left.  This
is not guaranteed by the language, however, and it is possible that
some compilers evaluate from left to right.  Therefore, if
when the parser itself is built, it can be compiled with the
macro REVERSE defined as 1.  This will build a parser that reverses
the order of assignment above.  Thus, if the parser is compiled
with REVERSE defined,
\begin{quote}
next():$>$ reset();
\end{quote}
will be translated to
\begin{quote} \tt
((int (*)())\_deref(tmpObjVar = next(), "reset" )) (tmpObjVar);
\end{quote}
This procedure is automated in the source files for ClassC.  Typing
{\em build} at the command line prompt will cause a test file to be
compiled and run.  The returned result of the test file indicates
whether normal or reverse argument evaluation is implemented in
the host C compiler.  Then, if the host version of {\bf make} accepts
the {\bf -e} (environment) option, {\bf make} will be called and the correct
version of the parser will be generated.  If make does not accept
the {\bf -e} option, the user must simply edit the makefile and define
the macro {\em SWITCH} appropriately ( {\em SWITCH= } for normal compilers;
{\em SWITCH=-DREVERSE} for others).

The only problem now is if there is yet another function dereference:

\noindent next():$>$reset():$>$double();

Now we need two temporary variables.  And so on.  This is solved by
creating an external array ``int indArr[99];'', and keeping track
of the expression dereferencing depth.

The limitation of this solution is that object function
dereferences are restricted to a depth of 99.

\subsection{The Inline Dereferencing Optimization}

Inline dereferencing of object components for ClassC:

Objects variables in ClassC are really integers which index into 
an object table.  Each entry in the object table contains information
about that object, such as a pointer to the actual data object itself.

In the original version of ClassC, object member dereferencing is done
by a C function call.  A table is created for each class which 
lists name/offset pairs.  A pointer to the appropriate class table
is included as one field in each object table entry.  When an object
member is referenced, the member name and class table pointer is
given to the deref() function, which searches through the table with
the member name as and index, and returns the associated offset.

This is an effective dereferencing mechanism, but rather slow, as it
involves a function call and linear table search for every object
dereference.

The inline dereferencing mechanism avoids both the function call 
as well as table search overhead as follows:

A list of all member names is made for each class.

The member names are hashed as indices into a table of size N
(where N is the smallest power of two greater than the number of
members in the class being processed).  The names are hashed by
calling the function {\tt string-to-unsigned-long()} with the member
name as an argument.  The value returned is an unsigned long
integer generated from the characters of the name string.  There are
over 4 billion possible values, and so the integer returned is
likely to be unique for every name.
This long integer is then masked by the value $N-1$ to produce
the desired hash index value $< N$.

If there is a collision, the table size is doubled, and the names rehashed.

If there is another a collision, the table size is doubled again.

This is repeated until:
\begin{enumerate}
\item No collisions occur, or
\item Table size exceeds 16*N.
\end{enumerate}

If the table size exceeds 16 times the number of members in the class, a
warning message is sent to the user and compilation is stopped.
The warning message indicating that the table has grown
too large and the name of the class and member on which collision has
occurred.  The user can then change the name slightly to avoid the collision.
This occurrence is rare, but prevents runaway table sizes.

Each class then has an array of offsets associated with it, where the
number of elements in the array is no more that 16 times the number of
members in the class.  The elements of the array are the offsets of
the class members.  The array is thus a sparse hash table with no
collisions.

A pointer to the appropriate array is included as a field in each
object table entry, as well as a mask value determined by the size of the
array ($ mask = arraySize^{2} - 1 $).

An object member dereference is now fairly efficient.  Each member
name is hashed into an integer at compile time, saving runtime
string manipulations.

Note that the integer to which a member name is converted is not
dependent on the class of the object to which the member belongs.
That is, the the number depends on the letters of the member name
string alone, and the class to which the member belongs NEED NOT
be known at compile time.  A unique (or rather, class-specific)
index is produced at runtime by {\bf AND}ing the integer with a mask
value stored in the object table which {\em is} dependent on the
object type (class).  This combines the advantage of doing
the hard work at compile time (thus saving execution time for
the running code) with the flexibility of not determining the true
hash index until runtime, allowing dynamic binding (that is, the type
(class) of the dereferenced object need not be known until run time).

So the result of the member name hash is {\tt AND}ed at runtime with the
appropriate mask value (as found in the object table entry) and then used
as an index into a table (the address of which is also found in the object
table entry) which returns the byte offset of the object member sought.

Example:

E source code:
\begin{quote} \tt
myObject:>memval = 6
\end{quote}
Is converted to the resultant C code for ---\\
Old style function dereference:
\begin{quote} \tt
(*(int  *)\_deref(myObject , "memval")) = 6; 
\end{quote}
\begin{quote}
	Explanation:\\
	The object table index, {\tt myObject}, and member name {\tt memval} are
	passed to the function {\tt \_deref()}, which returns a pointer 
	which is cast to as a pointer to integer and then dereferenced.
\end{quote}
New \& Improved Inline dereference:
\begin{verbatim}
(*(int  *) ((_objV[1]=_objTbl+ myObject )->self+ _objV[1]->
    hofV[/* "memval" */ 0xa5d05bf4 &_objV[1]->hashV])) = 6;
\end{verbatim}
\begin{quotation}

	Explanation:\\
	\_objTbl is the base pointer of the object table.

	\_objV[1] is the pointer to the desired entry of the object
	table obtained by adding the object index (myObject) to the
	base, \_objTbl.

	``self'' is the pointer to the object data in memory.

	``hofV'' is the pointer to the table of offsets for the class.

	0xa5d05bf4 is the number that ``memval'' is hashed to.

	``hashV'' is the mask ANDed to 0xa5d05bf4 to get the appropriate index
	into the table ``hofV''

	All this returns an address in memory which is cast as a pointer to
	integer and then dereferenced.
\end{quotation}

The first form (using the {\tt \_deref()} function) is somewhat more readable.
The second form is much faster.

Why double the table size every time there is a collision?
Another alternative would be to increment the table size rather than
double it.  The masking operation could be replaced by a mod (remainder)
operation.  This would result in much more compact tables.

This is an alternative.  The arguments against it are as follows:
\begin{enumerate}
\item Mod'ing is much slower than masking.  Although it is represented as
a basic operation in C, equivalent to addition or masking, it is
actually implemented as a multi-step assembly language routine
in most computer systems.
\item The space used in the sparse hash tables is not particularly significant.
Recall that the tables are created not for each object, but one for each
class.  If we estimate the average table sparseness to be 1/8 and the
offset to be a 2 byte short integer, then each class member will take up
an average table space of 16 bytes.  If we assume that the average 
member name is 8 characters long, then with the old function call
dereferencing mechanism, each class member took an average table space
of 10 bytes.  If we multiply these numbers by the expected number
of classes and members per class in a system, we see that the table
space taken by either method is not a significant portion of the 
run time memory usage of an application program.
\end{enumerate}

This description only discussed object data members.  Object function
members are dealt with similarly, having separate hash tables of
absolute function addresses rather than relative offsets.

\subsubsection{Problems with Inline Dereferencing}
Unfortunately, the inline dereferencing option causes segmentation
faults on some machines, and peculiar behaviour on other machines
when the reference chain becomes too long; that is when an object
dereferences an object member which dereferences another object member
in turn, e.g.
\begin{quote} \tt
an\_object:$>$another\_object:$>$yet\_another\_object ...
\end{quote}

So, while a clever idea in theory, the inline dereferencing is 
not as portable as the slower function dereferencing mechanism
originally designed into ClassC.  Thus, function dereferencing is
the default, which can be over-ridden at compile time by 
the option ``-i'' when invoking the ClassC compiler {\bf ce}.
%\newpage
